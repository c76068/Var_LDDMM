function [obj_evol]=flow(obj,X_evol,P_evol,defo,tf)
%  computes the evolution of the obj under the flow generated by X/P.
%
% Input :
%  obj: particles 
%  X_evol{t}.center : points (position) at time t in a (n x d) matrix.
%  X_evol{t}.vector : a cell contains first  and second vectors of the 2-vector at time t.
%  P_evol{t}.center : is a (n x d) matrix containing the spatial momentums at time t.
%  P_evol{t}.vector : a cell contains momentums about first  and second vectors of the 2-vector..
%  defo : structure containing the parameters of deformations (kernel_size_mom,method,nstep,...)
%  final_time : final time (optional, and fixed by default to 1)
%
% Output
%  obj_evol : a cell list containing evolution path of obj ( a n x d matrix and i ranges from 1 to defo_options.nstep+1)



   method = defo.odemethod;
%  method = 'rk4';
   if nargin == 4
    tf=1;
   end

if strcmp(method,'middle_point')
    obj_evol = mpt(obj,X_evol,P_evol,defo,tf);
end

 if strcmp(method,'rk4')
    obj_evol = rk4(obj,X_evol,P_evol,defo,tf);
 end



end

function obj_evol=mpt(obj,X_evol,P_evol,defo,tf)


% [~,d] =size(X_init.center);
if nargin == 4
    tf=1;
end

obj_evol = cell(1,defo.nb_euler_steps+1);
% X_evol=cell(1,defo.nb_euler_steps+1);
% P_evol=cell(1,defo.nb_euler_steps+1);


dt=tf/defo.nb_euler_steps;

obj_evol{1} = obj;
% X_evol{1} = X_init;
% P_evol{1} = P_init;


for i=1:defo.nb_euler_steps
    
      nobj_1 = fdh(obj_evol{i},X_evol{i},P_evol{i},defo,dt/2); 
      nobj_2 = fdh(nobj_1,add_XY_h(X_evol{i},X_evol{i+1},[0.5 0.5]),add_XY_h(P_evol{i},P_evol{i+1},[0.5 0.5]),defo,dt);
    
      obj_evol{i+1} = obj_evol{i} + nobj_2 - nobj_1;
%     [nX1,nP1]=fdh(X_evol{i},P_evol{i},defo,dt/2);
%     [nX2,nP2]=fdh(nX1,nP1,defo,dt);
%     
%     X_evol{i+1} = add_XY_h(X_evol{i},add_XY_h(nX2,nX1,[1,-1]),1);
%     P_evol{i+1} = add_XY_h(P_evol{i},add_XY_h(nP2,nP1,[1,-1]),1);
    
end
end

function obj_evol =rk4(obj,X,P,defo,tf)

% [~,d] =size(X_init.center);
if nargin == 4
    tf=1;
end

obj_evol = cell(1,defo.nb_euler_steps+1);
% X_evol=cell(1,defo.nb_euler_steps+1);
% P_evol=cell(1,defo.nb_euler_steps+1);


dt=tf/defo.nb_euler_steps;

obj_evol{1} = obj;
% X_evol{1} = X_init;
% P_evol{1} = P_init;

for i=1:defo.nb_euler_steps
   
    
    k_1 = fdh(obj_evol{i},X{i},P{i},defo,dt);
    k_2 = fdh(obj_evol{i}+0.5*k_1,add_XY_h(X{i},X{i+1},[0.5,0.5]),add_XY_h(P{i},P{i+1},[0.5,0.5]),defo,dt);
    k_3 = fdh(obj_evol{i}+0.5*k_2,add_XY_h(X{i},X{i+1},[0.5,0.5]),add_XY_h(P{i},P{i+1},[0.5,0.5]),defo,dt);
    k_4 = fdh(obj_evol{i}+k_3,X{i+1},P{i+1},defo,dt);
    
    obj_evol{i+1} = obj_evol{i} + (k_1+2*k_2+2*k_3+k_4)/6;
   
    
end
end


function nobj=fdh(obj,X,P,defo,h)
   
   switch defo.method
    case 'keops'
        nobj=fdh_keops(obj,X,P,defo,h);
    case 'matlab'
        nobj=fdh_mat(obj,X,P,defo,h);
   end
end

function nobj=fdh_mat(obj,X,P,defo,h)
% This function implements an elementary Euler Step (pure matlab)
%
% Inputs :
% Input :
%  obj:
%  X.center : points (position) in a (n x d) matrix.
%  X.vector : a cell contains first  and second vectors of the 2-vector.
%  P.center : is a (n x d) matrix containing the spatial momentums.
%  P.vector : a cell contains momentums about first  and second vectors of the 2-vector..
%  defo: is a structure of deformations.
%  h is the time step.

% Outputs
%  nY.center : (n x d) matrix containing the new points.
%  nY.vector : a cell contains first  and second vectors of the new 2-vector.



[nx,d]=size(X.center);
[ny,~]=size(obj);
S=zeros(ny,nx);

for l=1:d
    S=S+(repmat(obj(:,l),1,nx)-repmat(X.center(:,l)',ny,1)).^2;
end


 if isfield(X,'vector') == 0
    m = 0;     
 else         
    m = length(X.vector);    
 end

 switch m
     case 0
        Gamma_0 = rho(S,0,defo.kernel_size_mom);
        dobj =  Gamma_0*P.center;
        
     case 1
     
        Gamma_0 = rho(S,0,defo.kernel_size_mom);
        Gamma_1 = rho(S,1,defo.kernel_size_mom);
        A = repmat(diag(X.center*(X.vector{1})')',ny,1)-obj*(X.vector{1})';


        switch defo.action
           case 'normalized'
              dobj =  Gamma_0*P.center + 2*(Gamma_1.*A)*PJ(P.vector{1},X.vector{1});
        
           case 'pushforward'

              dobj =  Gamma_0*P.center + 2*(Gamma_1.*A)*P.vector{1};
        end

    
     case 2
    
        Gamma_0 = rho(S,0,defo.kernel_size_mom);
        Gamma_1 = rho(S,1,defo.kernel_size_mom); 
 
        A_1 = repmat(diag(X.center*(X.vector{1}'))',ny,1) - obj*(X.vector{1}');
        A_2 = repmat(diag(X.center*(X.vector{2}'))',ny,1) - obj*(X.vector{2}');
        dobj = Gamma_0*P.center + 2*(Gamma_1.*A_1)*P.vector{1} + 2*(Gamma_1.*A_2)*P.vector{2};
 end 
   
 
    switch defo.odemethod
        
        case 'middle_point'
            nobj = obj + h*dobj; 
        case 'rk4'
            nobj = h*dobj; 
    end

end

function nobj=fdh_keops(obj,X,P,defo,h)
% This function implements an elementary Euler Step with keops
%
% Inputs :
% Input :
%  obj:
%  X.center : points (position) in a (n x d) matrix.
%  X.vector : a cell contains first  and second vectors of the 2-vector.
%  P.center : is a (n x d) matrix containing the spatial momentums.
%  P.vector : a cell contains momentums about first  and second vectors of the 2-vector..
%  defo: is a structure of deformations.
%  h is the time step.

% Outputs
%  nY.center : (n x d) matrix containing the new points.
%  nY.vector : a cell contains first  and second vectors of the new 2-vector.



[nx,d]=size(X.center);
[ny,~]=size(obj);

% m=length(X.vector);
 if isfield(X,'vector') == 0
    m = 0;     
 else         
    m = length(X.vector);    
 end
 
switch m
    case 0
      V = Kernel('Exp(-p*SqNorm2(x-y))*p1',['x=Vx(' num2str(d) ')'],['y=Vy(' num2str(d) ')'],['p1=Vy(' num2str(d) ')'],'p=Pm(1)');
      x = obj';
      y = X.center';
      p = P.center';
      oos2 = 1/defo.kernel_size_mom^2; 
      
      dobj = V(x,y,p,oos2)';
      
    case 1
    
      V = Kernel('Exp(-p*SqNorm2(x-y))*p1+Grad(Grad(Exp(-p*SqNorm2(x-y))*p2,y,h),h,u)',...
      ['x=Vx(' num2str(d) ')'],['y=Vy(' num2str(d) ')'],['p1=Vy(' num2str(d) ')'],...
      ['p2=Vy(' num2str(d) ')'],['u=Vy(' num2str(d) ')'],'p=Pm(1)',['h=Vy(' num2str(d) ')']);

      x = obj';
      y = X.center';
      u = X.vector{1}';
      p1 = P.center';
      p2 = P.vector{1}';

      dum = u;

      oos2 = 1/defo.kernel_size_mom^2; 
    
      switch defo.action
         case 'normalized'
            dobj = V(x,y,p1,PJ(P.vector{1},X.vector{1})',u,oos2,dum)';  
         case 'pushforward'
            dobj = V(x,y,p1,p2,u,oos2,dum)';  
      end
    
    case 2
    
       V = Kernel('Exp(-p*SqNorm2(x-y))*p0+Grad(Grad(Exp(-p*SqNorm2(x-y))*p1,y,h),h,u1)+Grad(Grad(Exp(-p*SqNorm2(x-y))*p2,y,h),h,u2)',...
       ['x=Vx(' num2str(d) ')'],['y=Vy(' num2str(d) ')'],['p0=Vy(' num2str(d) ')'],...
       ['p1=Vy(' num2str(d) ')'], ['p2=Vy(' num2str(d) ')'], ['u1=Vy(' num2str(d) ')'],...
       ['u2=Vy(' num2str(d) ')'],'p=Pm(1)',['h=Vy(' num2str(d) ')']);


%     dV_ad = GradKernel(V,'x',['h1=Vx(' num2str(d) ')']);
%     dV = GradKernel(dV_ad,'h1',['h2=Vx(' num2str(d) ')']);
%     dV_2ad = GradKernel(dV_ad,'x',['h2=Vx(' num2str(d) ')']);
    
       x = obj';
       y = X.center';
       u1 = X.vector{1}';
       u2 = X.vector{2}';
       p0 = P.center';
       p1 = P.vector{1}';
       p2 = P.vector{2}';

       oos2 = 1/defo.kernel_size_mom^2;        
       dobj = V(x,y,p0,p1,p2,u1,u2,oos2,u1)';
end
    
    
    switch defo.odemethod
        
        case 'middle_point'
            nobj = obj + h*dobj; 
        case 'rk4'
            nobj = h*dobj; 
    end

    
end


